#!/usr/bin/env python3

# This test tests whether the foreground silhouette generated by gloss matches the one generated by Open3D (created using https://www.open3d.org/docs/latest/tutorial/geometry/ray_casting.html)
# The corresponding config for the test can be found in the `configs` folder in `tests/reference_tests`

import gloss
import os, os.path as osp
import numpy as np
import json
import cv2
from rich.progress import Progress

# To be called only once per process. Can select between Off,Error,Warn,Info,Debug,Trace
gloss.log.gloss_setup_logger(log_level=gloss.log.LogLevel.Info)

def test_silhouette():
    root_path = osp.dirname(osp.realpath(__file__))
    json_path = osp.join(root_path, '../reference_cameras.json')
    config_file = 'foreground_silhouette.toml'
    config_path = osp.join(root_path, config_file)
    assert osp.exists(config_path),  f"Config for the test ({config_file}) does not seem to exist!\n \
                                    Configs found - {os.listdir(osp.join(root_path, 'configs'))}"

    # Get path to data 
    data_path = osp.join(root_path, "../../../data")
    obj_path = os.path.join(data_path, "bust.obj")
    assert osp.exists(obj_path), "Mesh was not found!"

    # Create the HeadlessViewer
    viewer = gloss.ViewerHeadless(2048, 2048, config_path) # Dummy height width, will be overwritten
    device = viewer.get_device()
    queue  = viewer.get_queue()
    scene  = viewer.get_scene()

    # Read a mesh from file and add it to the scene
    scene.get_or_create_entity("body") \
        .insert_builder(gloss.geom.build_from_file(obj_path))

    with open(json_path, "r") as f:
        cameras = json.load(f)
    
    all_num_different_pixels = []

    with Progress() as progress:
        task = progress.add_task("Testing gloss against reference silhouettes", total=len(cameras))
        for camera in cameras:

            # Set camera parameters
            cam = viewer.get_camera()
            cam.set_extrinsics(np.array(camera["extrinsics"], dtype = np.float32))
            cam.set_intrinsics(*camera["intrinsics"])
            cam.set_width_height(camera["width"], camera["height"])
            camera_id = camera["id"]
            
            # Render once
            viewer.start_frame()
            viewer.update()

            # Get the last image we rendered as a numpy array
            gloss_render = viewer.get_final_tex()
            gloss_render_np = gloss_render.numpy(device, queue)
            gloss_silhouette = gloss_render_np[..., 3]

            path_to_reference = osp.join(root_path, "references", str(camera_id) + ".png")
            reference_silhouette = cv2.imread(path_to_reference, cv2.IMREAD_UNCHANGED)

            image_difference = gloss_silhouette - reference_silhouette
            
            num_different_pixels = (abs(image_difference).sum() / 255)
            percentage = 100 * (num_different_pixels / (camera["height"] * camera["width"]))
            all_num_different_pixels.append(f'{percentage:.4f}%')

            assert percentage < 0.1, f"[TEST FAILED] Image difference is larger than 0.1%, {int(num_different_pixels)} different pixels!"
            progress.update(task, advance=1)

    print("[ALL TESTS SUCCEEDED] with an image difference of less than 0.1%")
    print("Percentage of the image with pixels that are not exactly the same - ", all_num_different_pixels)